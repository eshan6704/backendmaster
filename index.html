<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Stock Data Frontend — Candles & Indicators</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      font-family: sans-serif;
      overflow: hidden;
    }

    /* TOP BAR layout (25% / 15% / 60%) */
    .form-row {
      display: flex;
      align-items: center;
      padding: 0.4rem;
      background: #f5f5f5;
      border-bottom: 1px solid #ccc;
      height: 44px;
      width: 100%;
      box-sizing: border-box;
    }
    .form-left { width: 25%; font-weight: bold; padding-left: 8px; }
    .form-center { width: 15%; display:flex; justify-content:center; align-items:center; font-weight:bold;}
    .form-right { width: 60%; display:flex; justify-content:flex-end; gap: 0.6rem; align-items:center; }

    input, select { padding: 0.28rem; font-size: 0.95rem; }
    select { width: 130px; }
    button { padding: 0.32rem 0.6rem; cursor:pointer; }

    /* OUTPUT iframe area */
    #output {
      width: 100%;
      height: calc(100% - 44px);
      overflow: hidden;
      display: block;
    }
    #resultFrame { width: 100%; height: 100%; border: none; }

    /* CHART AREA */
    #chart {
      width: 100%;
      height: calc(100% - 44px);
      display: none;
      overflow: auto;
      background: #fff;
      box-sizing: border-box;
      padding: 8px;
    }

    /* Chart container & controls inside chart div */
    #chartTop {
      width: 100%;
      max-height: 65%;         /* chart area */
      box-sizing: border-box;
      background: #fff;
      border: 1px solid #ddd;
      margin-bottom: 8px;
      display: flex;
      flex-direction: column;
    }
    #plotlyChart {
      width: 100%;
      height: 520px; /* main visible chart height */
    }

    #chartControls {
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 6px;
      border-bottom: 1px solid #eee;
      background: #fafafa;
    }

    /* extracted table below chart */
    #extractedTableWrap {
      width: 100%;
      height: calc(35% - 16px);
      overflow: auto;
      border: 1px solid #eee;
      padding: 8px;
      box-sizing: border-box;
      background: #fff;
    }
    table.extracted {
      border-collapse: collapse;
      width: 100%;
    }
    table.extracted th, table.extracted td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      white-space: nowrap;
    }

    /* small UI tweaks */
    .small { font-size: 0.88rem; }
    .spacer { width: 12px; }
  </style>
</head>
<body>

  <div class="form-row">
    <div class="form-left">Page designed by Eshan Patel - 9730425081</div>
    <div class="form-center" id="clock">--/--/---- --:--</div>

    <div class="form-right">
      <label class="small">Symbol <input id="symbol" value="PNB" /></label>
      <label class="small">Type 
        <select id="reqtype">
          <option value="info">info</option>
          <option value="intraday">intraday</option>
          <option value="daily">daily</option>
          <option value="qresult">qresult</option>
          <option value="result">result</option>
          <option value="balance">balance</option>
          <option value="cashflow">cashflow</option>
          <option value="dividend">dividend</option>
          <option value="split">split</option>
          <option value="other">other</option>
        </select>
      </label>

      <button id="sendBtn">Fetch</button>
      <button id="toggleBtn">Show Chart</button>
    </div>
  </div>

  <!-- IFRAME OUTPUT -->
  <div id="output">
    <iframe id="resultFrame"></iframe>
  </div>

  <!-- CHART + extracted table -->
  <div id="chart">
    <div id="chartTop">
      <div id="chartControls">
        <label><input type="checkbox" id="sma20" /> SMA 20</label>
        <label><input type="checkbox" id="sma50" /> SMA 50</label>
        <label><input type="checkbox" id="ema20" /> EMA 20</label>
        <label><input type="checkbox" id="macd" /> MACD</label>
        <label><input type="checkbox" id="rsi" /> RSI</label>

        <div class="spacer"></div>

        <button id="downloadCsv">Export CSV</button>
        <button id="downloadPng">Download PNG</button>
        <button id="resetZoom">Reset Zoom</button>
      </div>

      <div id="plotlyChart"></div>
    </div>

    <div id="extractedTableWrap"><!-- filled with extracted table --></div>
  </div>

<script type="module">
  import { client } from "https://esm.run/@gradio/client";

  const SPACE_URL = "https://eshan6704-backendmaster.hf.space";
  let gradioClient;
  let lastData = null; // parsed array of objects [{date, open, high, low, close, volume}, ...]

  async function init() {
    gradioClient = await client(SPACE_URL);
    startClock();
  }

  async function fetchData() {
    const symbol = document.getElementById("symbol").value;
    const reqtype = document.getElementById("reqtype").value;

    try {
      const result = await gradioClient.predict("/fetch_data", [symbol, reqtype]);
      const htmlContent = result.data[0];

      const iframe = document.getElementById("resultFrame");
      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write(htmlContent);
      doc.close();
    } catch (err) {
      const iframe = document.getElementById("resultFrame");
      const doc = iframe.contentDocument || iframe.contentWindow.document;
      doc.open();
      doc.write("<h1>Error</h1><p>" + err.message + "</p>");
      doc.close();
    }
  }

  /* ---------- Utility: find matching header names ---------- */
  function pickColumnIndex(headers, candidates) {
    const low = headers.map(h => String(h || "").trim().toLowerCase());
    for (const cand of candidates) {
      const idx = low.indexOf(cand.toLowerCase());
      if (idx !== -1) return idx;
    }
    return -1;
  }

  /* ---------- Parsing helpers ---------- */
  function parseNumberCell(v) {
    if (v === null || v === undefined) return NaN;
    let s = String(v).trim();
    if (s === "" || s === "-" || s.toLowerCase() === "nan") return NaN;
    // remove commas and non-digit characters except dot and minus
    s = s.replace(/[^0-9.\-eE]/g, "");
    const n = parseFloat(s);
    return isFinite(n) ? n : NaN;
  }

  function parseDateCell(v) {
    // Try Date parsing robustly
    if (!v) return null;
    let s = String(v).trim();
    // common formats: dd/mm/yyyy, dd-mm-yyyy, yyyy-mm-dd
    // replace dots with hyphen, slashes with hyphen
    s = s.replace(/\./g, '-').replace(/\//g, '-');
    // if day/month/year and two-digit year, handle etc.
    const d = new Date(s);
    if (!isFinite(d)) {
      // try swapping dd-mm-yyyy -> yyyy-mm-dd if needed
      const parts = s.split('-').map(p => p.trim());
      if (parts.length === 3) {
        // detect if first part is year or day
        if (parts[0].length === 4) {
          // already year-first; let Date try again
          const d2 = new Date(s);
          if (isFinite(d2)) return d2;
        } else {
          // try reorder to yyyy-mm-dd
          const dstr = `${parts[2]}-${parts[1]}-${parts[0]}`;
          const d2 = new Date(dstr);
          if (isFinite(d2)) return d2;
        }
      }
      return null;
    }
    return d;
  }

  /* ---------- Extract table from iframe and parse ------------ */
  function extractTableOnDemand() {
    const iframe = document.getElementById("resultFrame");
    const doc = iframe.contentDocument || iframe.contentWindow.document;
    const table = doc.querySelector("table");
    const chartDiv = document.getElementById("chart");
    const wrap = document.getElementById("extractedTableWrap");

    if (!table) {
      wrap.innerHTML = "<h3>No table found in the output iframe.</h3>";
      lastData = null;
      drawEmpty();
      return;
    }

    // clone the table for display
    const cloned = table.cloneNode(true);
    // normalize rows & cells
    const rows = Array.from(cloned.querySelectorAll("tr"));
    if (rows.length === 0) {
      wrap.innerHTML = "<h3>No table rows found.</h3>";
      lastData = null;
      drawEmpty();
      return;
    }

    // extract header
    let headerCells = [];
    // prefer the first row with th or the first row
    const headerRow = rows.find(r => r.querySelectorAll('th').length > 0) || rows[0];
    headerCells = Array.from(headerRow.querySelectorAll('th, td')).map(c => c.textContent.trim());

    // build data rows (skip headerRow index if it's the header)
    const headerIndex = rows.indexOf(headerRow);
    const dataRows = rows.slice(headerIndex + 1);

    // build a 2D array of values
    const data = dataRows.map(r => Array.from(r.querySelectorAll('td, th')).map(c => c.textContent.trim()));

    // attempt to detect columns
    const h = headerCells.map(x => x.toLowerCase());
    const dateIdx = pickColumnIndex(headerCells, ['date', 'time', 'timestamp', 'dt']);
    const openIdx = pickColumnIndex(headerCells, ['open', 'o', 'op']);
    const highIdx = pickColumnIndex(headerCells, ['high', 'h']);
    const lowIdx = pickColumnIndex(headerCells, ['low', 'l']);
    const closeIdx = pickColumnIndex(headerCells, ['close', 'c', 'last', 'adj close', 'close*']);
    const volumeIdx = pickColumnIndex(headerCells, ['volume', 'vol', 'v']);

    // If header detection fails, try common positional fallback:
    // Many tables present Date Open High Low Close Volume in that order
    let fallback = false;
    if (dateIdx === -1 && data.length > 0 && data[0].length >= 6) fallback = true;

    const parsed = [];
    for (let r = 0; r < data.length; r++) {
      const row = data[r];
      // skip empty rows
      if (row.every(cell => cell === "")) continue;

      const dateCell = !fallback ? row[dateIdx] : row[0];
      const openCell = !fallback ? row[openIdx] : row[1];
      const highCell = !fallback ? row[highIdx] : row[2];
      const lowCell = !fallback ? row[lowIdx] : row[3];
      const closeCell = !fallback ? row[closeIdx] : row[4];
      const volumeCell = !fallback ? row[volumeIdx] : row[5];

      const dateObj = parseDateCell(dateCell);
      const open = parseNumberCell(openCell);
      const high = parseNumberCell(highCell);
      const low = parseNumberCell(lowCell);
      const close = parseNumberCell(closeCell);
      const volume = parseNumberCell(volumeCell);

      // require date and close to be valid
      if (!dateObj || isNaN(close)) continue;

      parsed.push({
        date: dateObj,
        open: isNaN(open) ? close : open,
        high: isNaN(high) ? close : high,
        low: isNaN(low) ? close : low,
        close: close,
        volume: isNaN(volume) ? 0 : volume
      });
    }

    // sort by date ascending
    parsed.sort((a,b) => a.date - b.date);

    lastData = parsed;

    // display cloned table in extracted area
    wrap.innerHTML = "";
    // add a heading and attach cloned table (with styling)
    const head = document.createElement('div');
    head.className = 'small';
    head.textContent = `Extracted table (${parsed.length} rows) — raw view:`;
    wrap.appendChild(head);
    cloned.className = 'extracted';
    cloned.style.minWidth = '700px';
    cloned.querySelectorAll('td,th').forEach(c => {
      c.style.padding = '6px 10px';
      c.style.border = '1px solid #ccc';
      c.style.whiteSpace = 'nowrap';
    });
    wrap.appendChild(cloned);

    // after parsing data, draw chart
    buildAndDrawChart();
  }

  /* ---------- Chart & indicators computation ---------- */

  function sma(values, period) {
    const res = [];
    let sum = 0;
    for (let i=0;i<values.length;i++) {
      sum += values[i];
      if (i >= period) sum -= values[i - period];
      if (i >= period - 1) res.push(sum / period);
      else res.push(null);
    }
    return res;
  }

  function ema(values, period) {
    const res = [];
    const k = 2 / (period + 1);
    let prev = values[0]; // seed
    res.push(prev);
    for (let i=1;i<values.length;i++) {
      const val = values[i];
      const cur = val * k + prev * (1 - k);
      res.push(cur);
      prev = cur;
    }
    // For first (period-1) entries result will be present but user expects nulls earlier.
    // We'll pad with nulls to be consistent: set first (period-1) to null
    for (let i=0;i<period-1 && i<res.length;i++) res[i] = null;
    return res;
  }

  function rsi(values, period=14) {
    const deltas = [];
    for (let i=1;i<values.length;i++) deltas.push(values[i] - values[i-1]);
    let ups = 0, downs = 0;
    for (let i=0;i<period;i++) {
      const d = deltas[i] || 0;
      if (d >= 0) ups += d; else downs += Math.abs(d);
    }
    let avgUp = ups / period, avgDown = downs / period;
    const rsis = [ ...Array(period).fill(null) ]; // first `period` entries null
    for (let i=period;i<deltas.length;i++) {
      const d = deltas[i];
      const up = d > 0 ? d : 0;
      const down = d < 0 ? Math.abs(d) : 0;
      avgUp = (avgUp * (period - 1) + up) / period;
      avgDown = (avgDown * (period -1) + down) / period;
      const rs = avgDown === 0 ? 100 : avgUp / avgDown;
      const rsiVal = avgDown === 0 ? 100 : 100 - (100 / (1 + rs));
      rsis.push(rsiVal);
    }
    // align to original length: add a null at index 0 to match length
    rsis.unshift(null);
    // ensure length matches values.length
    while (rsis.length < values.length) rsis.unshift(null);
    return rsis;
  }

  function macd(values, fast=12, slow=26, signal=9) {
    const emaFast = ema(values, fast);
    const emaSlow = ema(values, slow);
    const macdLine = values.map((v,i)=> {
      if (emaFast[i] == null || emaSlow[i] == null) return null;
      return emaFast[i] - emaSlow[i];
    });
    const signalLine = ema(macdLine.map(x => x === null ? 0 : x), signal);
    const hist = macdLine.map((m,i)=> {
      if (m == null || signalLine[i] == null) return null;
      return m - signalLine[i];
    });
    return { macd: macdLine, signal: signalLine, hist };
  }

  /* ---------- Build Plotly chart ---------- */

  function buildAndDrawChart() {
    if (!lastData || lastData.length === 0) {
      drawEmpty();
      return;
    }

    const dates = lastData.map(d => d.date);
    const opens = lastData.map(d => d.open);
    const highs = lastData.map(d => d.high);
    const lows = lastData.map(d => d.low);
    const closes = lastData.map(d => d.close);
    const volumes = lastData.map(d => d.volume);

    // base traces
    const candle = {
      x: dates,
      open: opens,
      high: highs,
      low: lows,
      close: closes,
      type: 'candlestick',
      name: 'Price',
      increasing: {line: {color: '#2ca02c'}},
      decreasing: {line: {color: '#d62728'}},
      xaxis: 'x',
      yaxis: 'y'
    };

    const volBar = {
      x: dates,
      y: volumes,
      type: 'bar',
      name: 'Volume',
      marker: { color: 'rgba(100,100,100,0.6)' },
      xaxis: 'x',
      yaxis: 'y2',
      opacity: 0.6
    };

    // indicators (computed only if selected)
    const traces = [candle, volBar];

    // SMA & EMA overlays (on price)
    const enableSMA20 = document.getElementById('sma20').checked;
    const enableSMA50 = document.getElementById('sma50').checked;
    const enableEMA20 = document.getElementById('ema20').checked;
    const enableMACD = document.getElementById('macd').checked;
    const enableRSI = document.getElementById('rsi').checked;

    if (enableSMA20) {
      const sma20 = sma(closes, 20);
      traces.push({
        x: dates,
        y: sma20,
        mode: 'lines',
        name: 'SMA 20',
        line: { width: 1.5 },
        yaxis: 'y'
      });
    }
    if (enableSMA50) {
      const sma50 = sma(closes, 50);
      traces.push({
        x: dates,
        y: sma50,
        mode: 'lines',
        name: 'SMA 50',
        line: { width: 1.5 },
        yaxis: 'y'
      });
    }
    if (enableEMA20) {
      const ema20v = ema(closes, 20);
      traces.push({
        x: dates,
        y: ema20v,
        mode: 'lines',
        name: 'EMA 20',
        line: { dash: 'dash', width: 1.3 },
        yaxis: 'y'
      });
    }

    // MACD & RSI build separate subplots below
    const layout = {
      grid: { rows: enableMACD || enableRSI ? 3 : 2, columns: 1, pattern: 'independent', roworder: 'top to bottom' },
      margin: { t: 30, b: 30, l: 60, r: 30 },
      showlegend: true,
      xaxis: { domain: [0,1], rangeslider: { visible: false } },
      yaxis: { domain: enableMACD || enableRSI ? [0.35, 1] : [0.2, 1], title: 'Price' },
      yaxis2: { domain: enableMACD || enableRSI ? [0.15, 0.3] : [0, 0.2], title: 'Volume', showticklabels: true },
      // additional axes for MACD/RSI if present
    };

    // For multi-row grid, assign yaxis names for traces
    // candlestick uses yaxis (y), volume uses y2
    // We'll set up MACD in row 2 and RSI in row 3 (if both), else only one of them.

    // Build MACD traces if enabled
    const extraTraces = [];
    if (enableMACD) {
      const macdRes = macd(closes, 12, 26, 9);
      extraTraces.push({
        x: dates,
        y: macdRes.macd,
        mode: 'lines',
        name: 'MACD',
        yaxis: 'y3'
      });
      extraTraces.push({
        x: dates,
        y: macdRes.signal,
        mode: 'lines',
        name: 'Signal',
        yaxis: 'y3',
        line: { dash: 'dot' }
      });
      extraTraces.push({
        x: dates,
        y: macdRes.hist,
        type: 'bar',
        name: 'MACD Hist',
        yaxis: 'y3'
      });
    }
    // RSI
    if (enableRSI) {
      const rsiVals = rsi(closes, 14);
      extraTraces.push({
        x: dates,
        y: rsiVals,
        mode: 'lines',
        name: 'RSI(14)',
        yaxis: enableMACD ? 'y4' : 'y3'
      });
      // add overbought/oversold shapes later in layout
    }

    // Setup layout axes when MACD/RSI exist
    if (enableMACD || enableRSI) {
      // define y3 and y4 domains depending on which indicators enabled
      if (enableMACD && enableRSI) {
        layout.yaxis3 = { domain: [0.05, 0.12], title: 'MACD' };
        layout.yaxis4 = { domain: [0.0, 0.04], title: 'RSI' };
        // adjust main/volume domains
        layout.yaxis.domain = [0.35, 1];
        layout.yaxis2.domain = [0.2, 0.33];
      } else if (enableMACD) {
        layout.yaxis3 = { domain: [0.05, 0.2], title: 'MACD' };
        layout.yaxis.domain = [0.4, 1];
        layout.yaxis2.domain = [0.2, 0.38];
      } else if (enableRSI) {
        layout.yaxis3 = { domain: [0.05, 0.2], title: 'RSI' };
        layout.yaxis.domain = [0.4, 1];
        layout.yaxis2.domain = [0.2, 0.38];
      }
    }

    // final traces order: candle, overlays, volume, extraTraces
    // ensure volume is behind overlays visually by pushing it after candle
    const finalTraces = [];
    finalTraces.push(candle);
    // overlays were already appended to traces after candle; include them
    for (let t of traces.slice(1)) finalTraces.push(t);
    finalTraces.push(volBar);
    for (let t of extraTraces) finalTraces.push(t);

    // Build config (enable modebar)
    const config = { responsive: true, displaylogo: false, toImageButtonOptions: { format: 'png', filename: 'chart', height: 800, width: 1200 } };

    // Draw
    Plotly.newPlot('plotlyChart', finalTraces, layout, config).then(() => {
      // attach hovermode, etc.
    });
  }

  function drawEmpty() {
    const plotDiv = document.getElementById('plotlyChart');
    plotDiv.innerHTML = '<div style="padding:20px;color:#666">No data available to plot.</div>';
  }

  /* ---------- UI & events ---------- */
  function toggleView() {
    const output = document.getElementById("output");
    const chart = document.getElementById("chart");
    const btn = document.getElementById("toggleBtn");

    if (output.style.display === "none") {
      output.style.display = "block";
      chart.style.display = "none";
      btn.textContent = "Show Chart";
    } else {
      // Extract and build chart when switching to Chart
      extractTableOnDemand();
      output.style.display = "none";
      chart.style.display = "block";
      btn.textContent = "Show Output";
    }
  }

  // redraw when indicator toggles change
  function attachIndicatorEvents() {
    ['sma20','sma50','ema20','macd','rsi'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.addEventListener('change', () => {
        if (!lastData) return;
        buildAndDrawChart();
      });
    });
  }

  // Export CSV from lastData
  function exportCsv() {
    if (!lastData || lastData.length === 0) { alert('No data to export'); return; }
    const cols = ['date','open','high','low','close','volume'];
    const rows = lastData.map(r => {
      const dt = r.date.toISOString();
      return cols.map(c => r[c]).join(',');
    });
    const csv = ['date,open,high,low,close,volume', ...rows].join('\n');
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (document.getElementById('symbol').value || 'data') + '.csv';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  // Download PNG from plotly
  function downloadPng() {
    Plotly.toImage('plotlyChart', { format: 'png', height: 800, width: 1200 }).then(function(url) {
      const a = document.createElement('a');
      a.href = url;
      a.download = (document.getElementById('symbol').value || 'chart') + '.png';
      document.body.appendChild(a);
      a.click();
      a.remove();
    });
  }

  // reset zoom
  function resetZoom() {
    Plotly.relayout('plotlyChart', {
      'xaxis.autorange': true,
      'yaxis.autorange': true
    });
  }

  /* ---------- clock ---------- */
  function startClock() {
    function updateClock() {
      const now = new Date();
      const d = String(now.getDate()).padStart(2, '0');
      const mo = String(now.getMonth() + 1).padStart(2, '0');
      const y = now.getFullYear();
      const h = String(now.getHours()).padStart(2, '0');
      const m = String(now.getMinutes()).padStart(2, '0');
      document.getElementById("clock").textContent = `${d}/${mo}/${y} ${h}:${m}`;
    }
    updateClock();
    setInterval(updateClock, 1000);
  }

  /* ---------- init listeners ---------- */
  window.addEventListener("DOMContentLoaded", () => {
    document.getElementById("sendBtn").addEventListener("click", fetchData);
    document.getElementById("toggleBtn").addEventListener("click", toggleView);
    document.getElementById("downloadCsv").addEventListener("click", exportCsv);
    document.getElementById("downloadPng").addEventListener("click", downloadPng);
    document.getElementById("resetZoom").addEventListener("click", resetZoom);
    attachIndicatorEvents();
    init();
  });
</script>

</body>
</html>
